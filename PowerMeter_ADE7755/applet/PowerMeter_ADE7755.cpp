/* ArduGrid = Nanode + Power Meter using Analog ADE7755 IC + datastreaming to Pachube
=====================================================================================
V1.0
MercinatLabs / MERCINAT SARL France
By: Thierry Brunet de Courssou
http://www.mercinat.com
Created 11 Oct 2011
Last update: 30 Nov 2011
Project hosted at: http://code.google.com/p/ardugrid/ - Repository type: Subversion
Version Control System: TortoiseSVN 1.7.1, Subversion 1.7.1, for Window7 64-bit - http://tortoisesvn.net/downloads.html

Configuration
-------------
Hardware: Nanode v5 + Hoch Pulses Power Meter board using Analog ADE7755 IC
  -- http://hochgroup.en.alibaba.com/product/424588718-200841852/single_phase_electric_kilowatt_hour_ph_meter.html?tracelog=cgsotherproduct1
  -- http://www.analog.com/en/analog-to-digital-converters/energy-measurement/ade7755/products/product.html
  -- Hoch board has been modified to get high frequency CF and to get REVP power sign
  -- REVP is routed through an additional opto isolator

SW Arduino 1.0 IDE for Windows at http://files.arduino.cc/downloads/arduino-1.0-windows.zip
-- did not test with Arduino IDE 0022 or 0023

Project summary
---------------
Real-time streaming of energy production to grid & power sign (Production/Consumption)

Comments
--------
This code has been abundantly commented with lots of external links to serve as a tutorial for newbies

Hardware: Nanode + ADE7755 powermeter board with REVP routed through an additional opto coupler
 
Pulses generated by ADE7755 via opto-isolator and 18k pull-up resistor
- interrupt 1 is for digital pin 3 --> Power pulses
- digital pin 4 --> REVP sign of power  (sign detection is show on LED on pin 6)

// RAM space is very limited so use PROGMEM to conserve memory with strings
// However PROGMEM brings some instabilities, so not using it for now. 
// Will check from time to time if this is solved in future versions of 
// Arduino IDE and EtherCard library.

// As Pachube feeds may hang at times, we reboot regularly. 
// We will monitor stability then remove reboot when OK.

// The  datastream ID10 is a Nanode health indicator. This is simply incremeting a number so any
// interruption can be easily addentified as a discontinuity on the ramp graph shown on Pachube

// The last datastream ID11 is a Pachube health indicator. 
// The time between sending data to Pachube and receiving the acknowledge message
// is recorded. This will reveal if Pachube service is responding in a timely fashon. 

// Mercinat Etel test site Nanodes -- As we use one Nanode per sensor, making use of the MAC allows to assign IP by DHCP and identify each sensor
// -------------------------------
// Nanode: 1	Serial: 266	 Mac: 00:04:A3:2C:2B:D6 --> Grid Aurora
// Nanode: 2	Serial: 267	 Mac: 00:04:A3:2C:30:C2 --> Grid FemtoGrid
// Nanode: 3	Serial: 738	 Mac: 00:04:A3:2C:1D:EA --> Grid Skystream
// Nanode: 4	Serial: 739	 Mac: 00:04:A3:2C:1C:AC --> Grid RMS #1
// Nanode: 5	Serial: 740	 Mac: 00:04:A3:2C:10:8E --> Grid RMS #2
// Nanode: 6	Serial: 835	 Mac: 00:04:A3:2C:28:FA -->  6 m anemometer/vane
// Nanode: 7	Serial: 836	 Mac: 00:04:A3:2C:26:AF --> 18 m anemometer/vane
// Nanode: 8	Serial: 837	 Mac: 00:04:A3:2C:13:F4 --> 12 m anemometer/vane
// Nanode: 9	Serial: 838	 Mac: 00:04:A3:2C:2F:C4 -->  9 m anemometer/vane

// Pachube feeds assignement
// -------------------------
// The is one Pachube feed per sensor. This appears to be the most flexible scheme.
// Derived/computed feeds/datastreams may be uploaded later via the Pachube API
// Will post such applications on project repository 
//  38277  - Anemometer/Vane Etel  6 m -- https://pachube.com/feeds/38277
//  38278  - Anemometer/Vane Etel  9 m -- https://pachube.com/feeds/38278
//  38279  - Anemometer/Vane Etel 12 m -- https://pachube.com/feeds/38279
//  38281  - Anemometer/Vane Etel 18 m -- https://pachube.com/feeds/38281
//  35020  - Skystream    (ADE7755 via CF & REVP - modified Hoch Energy Meter board) -- https://pachube.com/feeds/35020
//  37668  - WT FemtoGrid (ADE7755 via CF & REVP - modified Hoch Energy Meter board) -- Private feed -- https://pachube.com/feeds/37668
//  37667  - WT Aurora on (ADE7755 via CF & REVP - modified Hoch Energy Meter board) -- Private feed -- https://pachube.com/feeds/37667
//  40385  - Grid RMS #1  (ADE7753 via SPI - Olimex Energy Shield) -- https://pachube.com/feeds/40385
//  40386  - Grid RMS #2  (ADE7753 via SPI - Olimex Energy Shield) -- https://pachube.com/feeds/40386
//  40388 -- Turbine A -- Private feed -- https://pachube.com/feeds/40388
//  40389 -- Turbine B -- Private feed -- https://pachube.com/feeds/40389
//  37267 -- newly built Nanode test feed (Mercinat) -- https://pachube.com/feeds/37267
//  40447 -- Free room for anyone to test the ArduWind code)   -- https://pachube.com/feeds/40447
//  40448 -- Free room for anyone to test the ArduGrid code)   -- https://pachube.com/feeds/40448
//  40449 -- Free room for anyone to test the ArduSky code)    -- https://pachube.com/feeds/40449
//  40450 -- Free room for anyone to test the SkyChube code)   -- https://pachube.com/feeds/40450
//  40451 -- Free room for anyone to test the NanodeKit code)  -- https://pachube.com/feeds/40451

========================================================================================================*/
 
#include <Time.h>

// START -- Powermeter section
// ============================

#include "WProgram.h"
void setup();
void loop();
void PowerMeterLoop ();
void PowerMeterPulse();
unsigned long PulseTimeNow = 0; // Time stamp (in millisecons) for pulse triggering the interrupt
unsigned long PulseTimeLast = 0; // Time stamp of the previous pulse
unsigned long PulseTimeInterval = 0; // Time interval since last pulse
unsigned long PulsesCumulatedTime = 0; // Time Interval since last power computation 
unsigned long PulsesNbr = 0;           // Number of pulses since last power computation 
unsigned long MinPulseTimeInterval = 1000000000; //2* 1000000.0; // minimaal 10sec tot 20sec was 1000000000;




float Frequency = 0;
float Power = 0;
float PowerNow = 0;
float PowerLast = 0;
boolean bPowerSign = 0;

// Misc.
// -----
int FirstLoop = 0;

// END -- PowerMeter section

int TRUE = 1;
int FALSE = 0;
int Samples = 0;

volatile unsigned int ledPin = 13;
volatile int state = LOW;



// **********************
// -- SETUP
// **********************
void setup()
{
 Serial.begin(9600);
 Serial.println("\n\nArduGrid V1 - MercinatLabs (30 Nov 2011)");
 
 // interrupt 1 on digital pin 3 for PowerMeter pulses
 attachInterrupt(0, PowerMeterPulse, RISING);
 PulseTimeLast = micros();
}
  

  
// **********************
// -- MAIN LOOP
// **********************


void loop()
{
 // Get PowerMeter data 
 // ********************
 PowerMeterLoop();
 
 PowerNow = PowerLast + Power;
 PowerLast = Power;
 
 
 //Serial.print(PowerLast);
 //Serial.print("\t");
 if (second() == (Samples*5))
  {
   Serial.print(PowerNow/Samples);
   Samples = 0;
   PowerNow = 0;
   PowerLast = 0;
   Serial.print("\t");
   Serial.print(Samples);
   Serial.print("\t");
   Serial.println(Power);
  }
 
 //delay(100);
 Samples++;

/* 
 if(Samples < 10)
  {
   PowerNow = PowerLast + Power;   // Micros() is more precise to compute pulse width that millis();
   PowerLast = PowerNow;
  } 
 if (Samples >= 10)
  {
   PowerNow = PowerLast/Samples;
   Serial.print(PowerLast);
   Serial.print("\t");
   Serial.print(PowerNow);
   Serial.print("\t");
   Serial.print(Samples);
   Serial.print("\t");
   Serial.println(Power);
   delay(100);
   Samples = 0;
   PowerNow = 0;
   PowerLast = 0;
  }   
 Samples++;  
 
 //if (FirstLoop <= 2) { return; } // Discard first sets of data to make sure you get clean data
   
// Serial.print("\nPower: ");
// Serial.print(PulsesNbr);
// Serial.print("\t");
// Serial.println(PulsesCumulatedTime);
 
 
    
// Serial.print("   watts");
// Serial.println("");
*/
}


// **********************
// -- FUNCTIONS
// **********************

void PowerMeterLoop ()    // START PowerMeter section
{
  // with micros()
  //Power = (1000000.0*PulsesNbr)/PulsesCumulatedTime;
  Frequency = (1000000.0*PulsesNbr)/PulsesCumulatedTime;
  Power = Frequency * 10.0;
  
  

  
//  Power = Power / 1.105;  // Calibration correction -- Thierry
//  if (!bPowerSign){ Power = -Power;}
  
//  bPowerSign = digitalRead(4);  // Read Power Sign REVP
  // show power sign on LED 6  (LED ON = Inverter Production)
//  if (bPowerSign){ digitalWrite(6, 0);} else {digitalWrite(6, 1);}

/*
  Serial.println("");  
  Serial.println("");  
  Serial.print("Frequency: ");
  Serial.print(Frequency,DEC);
  Serial.print(" Hz -- Power: ");
  Serial.print(Power,DEC);
  Serial.print(" watts -- Sign: ");
  //if (bPowerSign) { Serial.println("+ Production"); } else { Serial.println("- Consommation"); }
  //Serial.println("");
  
  Serial.print("    ");  
  Serial.print(PulsesNbr,DEC);
  Serial.print(" pulses   ");  
  Serial.print(PulsesCumulatedTime,DEC);
  Serial.print(" microseconds between pachube updates   "); 
  Serial.println("");
*/  

  PulsesCumulatedTime = 0;
  PulsesNbr = 0;
  MinPulseTimeInterval = 1000000000;
  
//  if (FirstLoop <= 3)
//  {
//    FirstLoop = FirstLoop + 1;
//    Serial.println("> First 2 loops, discard data <");
//  }
}


void PowerMeterPulse()
{
   noInterrupts();            // disable global interrupts
   PulseTimeNow = micros();   // Micros() is more precise to compute pulse width that millis();
   PulseTimeInterval = PulseTimeNow - PulseTimeLast;
   PulseTimeLast = PulseTimeNow;
   PulsesCumulatedTime = PulsesCumulatedTime + PulseTimeInterval;
   PulsesNbr++;
   interrupts();              // Re-enable Interrupts
}

/*

void loop()    // START PowerMeter section
{
  // with micros()
  //Frequency = (1000000.0*PulsesNbr)/PulsesCumulatedTime;
    
   // if(PulsesCumulatedTime == MinPulseTimeInterval)
   //  { 
   Power = PulsesNbr/PulsesCumulatedTime;  
   //Power = (1000000.0*PulsesNbr)/PulsesCumulatedTime;
   Serial.print(PulsesNbr,DEC);
   Serial.print("\t");
   Serial.print(PulsesCumulatedTime,DEC);
   Serial.print("\t");
   Serial.println(Power,DEC);

   if(PulsesCumulatedTime > MinPulseTimeInterval)
    {
     PulsesNbr=0;
     PulsesCumulatedTime = 0;
    } 
}





void PowerMeterPulse()
{
 noInterrupts();            // disable global interrupts
 PulseTimeNow = micros();   // Micros() is more precise to compute pulse width that millis();
 PulseTimeInterval = PulseTimeNow - PulseTimeLast;
 PulseTimeLast = PulseTimeNow;
 PulsesCumulatedTime = PulsesCumulatedTime + PulseTimeInterval;
 PulsesNbr++;
   
  // state = !state;
  // digitalWrite(ledPin, state);
 interrupts();              // Re-enable Interrupts
}

/*
void loop()
{
 PowerCounter++
 if(PowerCounter >= PulsCounter)
  {
    PowerCounter=0;
    PowerCounterLow++;
  }
 if(PowerCounterLow>=10)
  {
   PowerCounterLow=0;
   PowerCounterHigh++;
  }
 else 
  if(PowerCounterHigh >= 1000)
   {
    Serial.println(Power)
   }
  else PowerCounterHigh=0; 
  
*/

int main(void)
{
	init();

	setup();
    
	for (;;)
		loop();
        
	return 0;
}

